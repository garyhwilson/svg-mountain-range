{"version":3,"sources":["SVGMountainRange.js","modules/Utils.js","modules/Coords.js","modules/Render.js"],"names":["SVGMountainRange","Utils","_classCallCheck","this","_createClass","key","value","val","_typeof","Array","isArray","target","source","_this","isObject","Object","keys","forEach","assign","_defineProperty","mergeDeep","Coords","stage","initPeaks","peaks","valleys","flats","points","length","slice","definePeaks","count","minY","maxY","startWithPeak","subdividePeaks","detail","mapping","mapPointsToObject","coords","defineFlats","peakMinY","peakMaxY","Math","floor","random","valleyMinY","retryLimit","startY","retry","peakY","valleyY","insertDelta","defineValleyY","i","definePeakY","splice","point1","point2","passes","diff","abs","lowPoint","midpoint","spread","delta","arr","pass","subdivide","pointCount","xInc","width","point","push","x","y","height","pos","align","name","obj","stageWidth","index","desiredX","flatName","levelArea","Render","fill","shadow","ridge","svg","document","createElementNS","setAttribute","appendChild","createMountainPoly","color","gradient","createShadowPath","thickness","createRidgeline","id","stops","svgNS","namespaceURI","grad","x1","y1","x2","y2","stop","offset","defs","querySelector","insertBefore","firstChild","arguments","undefined","poly","map","coord","join","createGradient","path","startXOffset","startX","endX","lowestY","utils","config","defaultConfig","_config"],"mappings":"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","file":"svg-mountain-range.min.js","sourcesContent":["import Utils from './modules/Utils';\nimport Coords from './modules/Coords';\nimport Render from './modules/Render';\n\nexport default class SVGMountainRange {\n\n  constructor(obj) {\n    const utils = new Utils();\n\n    const config = obj || { };\n    const defaultConfig = {\n      stage: {\n        width: 600,\n        height: 300\n      },\n      peaks: {\n        count: 1,\n        detail: 4,\n        minY: 200,\n        maxY: 300\n      },\n      valleys: {\n        minY: 50\n      }\n    };\n\n    this._config = utils.mergeDeep(defaultConfig, config);\n\n    const {\n      initPeaks,\n      stage,\n      peaks,\n      fill,\n      shadow,\n      ridge,\n      valleys,\n      flats\n    } = this._config;\n\n    const coords = new Coords(stage, initPeaks, peaks, valleys, flats);\n    const svg = new Render(coords, stage, valleys, fill, shadow, ridge);\n\n    return svg;\n  }\n\n}\n","export default class {\n  /**\n   * Utility method for determing if variable is an object.\n   *\n   * @param {Object} val - The value to be tested if an object or not.\n   * @returns {boolean} Returns TRUE if the parameter is an object, otherwise FALSE.\n   */\n  isObject(val) {\n    return (val && typeof val === 'object' && !Array.isArray(val) && val !== null);\n  }\n\n  /**\n   * Perform a deep merge from source onto target.\n   *\n   * @param {Object} target\n   * @param {Object} source\n   * @returns {Object} Returns the results of the merge between the target and source objects.\n   */\n  mergeDeep(target, source) {\n    if (this.isObject(target) && this.isObject(source)) {\n      Object.keys(source).forEach((key) => {\n        if (this.isObject(source[key])) {\n          if (!target[key]) Object.assign(target, { [key]: {} });\n          this.mergeDeep(target[key], source[key]);\n        } else {\n          Object.assign(target, { [key]: source[key] });\n        }\n      });\n    }\n\n    return target;\n  }\n}\n","export default class {\n /**\n   * Returns x/y coordinate objects in an array with procedurally generate points.\n   *\n   * @param {Object} stage - The stage configuration object.\n   * @param {array} [initPeaks] - The initial defined peaks, instead of random.\n   * @param {Object} peaks - The peaks configuration object.\n   * @param {Object} valleys - The valleys configuration object.\n   * @param {array} [flats] - the flats configuration object.\n   * @returns {array} x/y coordinate objects in an array with procedurally generate points\n   */\n  constructor(stage, initPeaks, peaks, valleys, flats) {\n    let points = 0;\n\n    if (initPeaks && initPeaks.length) {\n      points = initPeaks.slice();\n    } else {\n      points = this.definePeaks(peaks.count, valleys.minY, peaks.minY, peaks.maxY, peaks.startWithPeak);\n    }\n\n    points = this.subdividePeaks(points, peaks.detail, valleys.minY, peaks.maxY);\n\n    const mapping = this.mapPointsToObject(stage, points);\n    let coords = 0;\n\n    if (flats) {\n      coords = this.defineFlats(mapping, flats);\n    } else {\n      coords = mapping;\n    }\n\n    return coords;\n  }\n\n  /**\n   * Returns a randomly generated y-axis point for a tall peak.\n   *\n   * @param {number} peakMinY - The minimum y-axis limit for the new point.\n   * @param {number} peakMaxY - The maximum y-axis limit for the new point.\n   * @returns {number} Randomly generated y-axis point for a tall peak.\n   */\n  definePeakY(peakMinY, peakMaxY) {\n    return Math.floor(Math.random() * (peakMaxY - peakMinY) + peakMinY);\n  }\n\n  /**\n   * Returns a randomly generated low valley y-axis value.\n   * @param {number} peakMinY - The minimum y-axis limit for a peak point.\n   * @param {number} valleyMinY - The minimum y-axis limit for a valley point.\n   * @returns {number} Randomly generated low valley y-axis value.\n   */\n  defineValleyY(peakMinY, valleyMinY) {\n    return Math.floor(Math.random() * (peakMinY - valleyMinY) + valleyMinY);\n  }\n\n  /**\n   * Returns an array of y-axis points.\n   *\n   * @param {number} count - The count of tallest mountain peaks.\n   * @param {number} valleyMinY - The lowest y-axis point.\n   * @param {number} peakMinY - The lowest y-axis point for the tallest peaks.\n   * @param {number} peakMaxY - The highest y-axis point for the tallest peaks.\n   * @param {boolean} [startWithPeak] - True if the left most point is a peak instead of a valley.\n   * @returns {array} Array of y-axis points that define the main geography of the mountain peaks.\n   */\n  definePeaks(count, valleyMinY, peakMinY, peakMaxY, startWithPeak) {\n    const retryLimit = 100;\n    const startY = startWithPeak ? peakMinY : valleyMinY;\n\n    let retry = 0;\n    let peakY = 0;\n    let valleyY = 0;\n    let points = 0;\n    let insertDelta = 1;\n\n    if (startWithPeak) {\n      points = [startY, this.defineValleyY(peakMinY, valleyMinY), startY];\n      insertDelta = 2;\n    } else {\n      points = [startY];\n    }\n\n    for (let i = 0; i < count * 2; i += 2) {\n      do {\n        peakY = this.definePeakY(peakMinY, peakMaxY);\n        retry += 1;\n      } while (retry < retryLimit && peakY > peakMaxY);\n\n      do {\n        valleyY = this.defineValleyY(peakMinY, valleyMinY);\n      } while (valleyY < valleyMinY);\n\n      points.splice(i + insertDelta, 0, peakY);\n      points.splice(i + insertDelta + 1, 0, valleyMinY);\n    }\n\n    return points;\n  }\n\n  /**\n   * Return random y-axis position based on two points.\n   *\n   * @param {number} point1 - First point to subdivide.\n   * @param {number} point2 - Second point to subdivide.\n   * @param {number} passes - The number of times to subdivide the points.\n   * @param {number} minY - The minimum y-axis limit for the new point.\n   * @param {number} maxY - The maximum y-axis limit for the new point.\n   * @returns Randomly offset Y-axis point.\n   */\n  subdivide(point1, point2, passes, minY, maxY) {\n    const retryLimit = 100;\n    const diff = Math.abs(point1 - point2);\n    const lowPoint = point1 < point2 ? point1 : point2;\n    const midpoint = Math.floor(diff / 2) + lowPoint;\n    const spread = Math.floor(midpoint / passes);\n\n    let retry = 0;\n    let delta = 0;\n\n    do {\n      delta = Math.floor(Math.random() * spread);\n      retry += 1;\n    } while (retry < retryLimit && (midpoint + delta > maxY || midpoint + delta < minY));\n\n    if (Math.floor(Math.random() * 2) === 1) {\n      delta *= -1;\n    }\n\n    return midpoint + delta;\n  }\n\n  /**\n   * Return array of random subdivided y-axis points.\n   *\n   * @param {array} points - An array of y-axis points.\n   * @param {number} passes - The number of times to subdivide the points.\n   * @param {number} minY - The minimum y-axis limit for the new point.\n   * @param {number} maxY - The maximum y-axis limit for the new point.\n   * @returns {array} Array of random subdivided y-axis points.\n   */\n  subdividePeaks(points, passes, minY, maxY) {\n    const arr = points.splice(0);\n\n    for (let pass = 0; pass < passes; pass += 1) {\n      for (let i = 0; i < arr.length - 1; i += 2) {\n        arr.splice(i + 1, 0, this.subdivide(arr[i], arr[i + 1], passes, minY, maxY));\n      }\n    }\n\n    return arr;\n  }\n\n  /**\n   * Return an array of X and Y coordinate objects.\n   * @function mapPointsToObject\n   * @memberof SVGMountainRange.coords\n   * @private\n   * @param {Object} stage - The stage configuration object.\n   * @param {array} points - An array of y-axis points.\n   * @returns Array of X and Y coordinate objects.\n   */\n  mapPointsToObject(stage, points) {\n    const pointCount = points.length;\n    const xInc = stage.width / (pointCount - 1);\n    const coords = [];\n\n    for (let point = 0; point < pointCount; point += 1) {\n      coords.push({\n        x: xInc * point,\n        y: stage.height - points[point]\n      });\n    }\n\n    return coords;\n  }\n\n  /**\n   * Returns a coordinates array with leveled y-axis values for a specific width at given positions.\n   *\n   * @param {array} coords - The coordinates array.\n   * @param {number} pos - The x-axis position to start leveling.\n   * @param {number} width - The width of the area to be leveled.\n   * @param {string} align - The alignment of either left or right.\n   * @param {string} name - The name of the leveled area.\n   * @returns Coordinate object with a leveled y-axis value for a specific width at a given\n   * position.\n   */\n  levelArea(coords, pos, width, align, name) {\n    const obj = coords.slice();\n    const stageWidth = obj[obj.length - 1].x - obj[0].x;\n\n    let index = 0;\n    let desiredX = Math.floor(stageWidth * pos);\n\n    switch (align) {\n      case 'right':\n        desiredX -= width;\n        break;\n\n      case 'center':\n        desiredX -= Math.floor(width / 2);\n        break;\n\n      default:\n        break;\n    }\n\n    for (let i = 0; i < obj.length; i += 1) {\n      if (!index && obj[i].x > desiredX) {\n        index = i;\n        obj[i].flatName = name;\n      } else if (index && obj[i].x - obj[index].x <= width) {\n        obj[i].y = obj[index].y;\n      }\n    }\n\n    return obj;\n  }\n\n  /**\n   * Returns the coordinates array with flattened areas.\n   *\n   * @param {array} coords - The coordinates array.\n   * @param {array} flats - The flats configuration array.\n   * @returns {array} The coordinates array with flattened areas.\n   */\n  defineFlats(coords, flats) {\n    let obj = coords.slice();\n\n    for (let i = 0; i < flats.length; i += 1) {\n      obj = this.levelArea(obj, flats[i].pos, flats[i].width, flats[i].align, flats[i].name);\n    }\n\n    return obj;\n  }\n\n}\n","export default class {\n\n  /**\n   * Create SVG of mountain peaks.\n   *\n   * @param {array} coords\n   * @param {Object} stage\n   * @param {Object} valleys\n   * @param {Object} fill\n   * @param {Object} shadow\n   * @param {Object} ridge\n   * @returns {Object}\n   */\n  constructor(coords, stage, valleys, fill, shadow, ridge) {\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    svg.setAttribute('width', stage.width);\n    svg.setAttribute('height', stage.height);\n    svg.appendChild(\n      this.createMountainPoly(\n        svg,\n        coords,\n        stage.width,\n        stage.height,\n        (fill) ? fill.color : null,\n        (fill) ? fill.gradient : null\n      )\n    );\n\n    if (shadow) {\n      svg.appendChild(this.createShadowPath(svg, stage.height, coords, valleys.minY, shadow.color, shadow.gradient));\n    }\n\n    if (ridge && ridge.color && ridge.thickness) {\n      svg.appendChild(this.createRidgeline(coords, ridge.color, ridge.thickness));\n    }\n\n    return svg;\n  }\n\n  /**\n   * Returns gradient definition.\n   *\n   * @param {Object} svg\n   * @param {string} id\n   * @param {Object} gradient\n   * @returns {Object}\n   * @todo Remove SVG parameters as a dependency.\n   * @todo Remove querySelector as a dependency.\n   */\n  createGradient(svg, id, gradient) {\n    const stops = gradient.stops;\n    const svgNS = svg.namespaceURI;\n    const grad = document.createElementNS(svgNS, 'linearGradient');\n\n    grad.setAttribute('id', id);\n    grad.setAttribute('x1', gradient.x1);\n    grad.setAttribute('y1', gradient.y1);\n    grad.setAttribute('x2', gradient.x2);\n    grad.setAttribute('y2', gradient.y2);\n\n    for (let i = 0; i < stops.length; i += 1) {\n      const stop = document.createElementNS(svgNS, 'stop');\n\n      stop.setAttribute('offset', stops[i].offset);\n      stop.setAttribute('stop-color', stops[i]['stop-color']);\n\n      grad.appendChild(stop);\n    }\n\n    const defs = svg.querySelector('defs') || svg.insertBefore(document.createElementNS(svgNS, 'defs'), svg.firstChild);\n    return defs.appendChild(grad);\n  }\n\n  /**\n   * Return SVG polygon element of mountain peaks.\n   *\n   * @param {Object} svg -\n   * @param {array} coords -\n   * @param {number} width -\n   * @param {number} height -\n   * @param {string} [color] -\n   * @param {Object} [gradient] -\n   * @returns {Object} SVG polygon element of mountain peaks.\n   * @todo Remove SVG parameters as a dependency.\n   */\n  createMountainPoly(svg, coords, width, height, color = '#000000', gradient) {\n    const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n    const points = coords.map(coord => `${coord.x},${coord.y}`).join(' ');\n\n    poly.setAttribute('points', `${points} ${width},${height} 0,${height}`);\n\n    if (gradient) {\n      this.createGradient(svg, 'mountainGradient', gradient);\n      poly.setAttribute('fill', 'url(#mountainGradient)');\n    } else {\n      poly.setAttribute('fill', color);\n    }\n\n    return poly;\n  }\n\n  /**\n   * Add a stroke to the mountain peak ridgeline.\n   *\n   * @param {array} coords -\n   * @param {string} [color] -\n   * @param {number} [thickness] -\n   * @returns {Object}\n   */\n  createRidgeline(coords, color = '#000000', thickness = 1) {\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    const pointCount = coords.length;\n\n    let points = `M ${coords[0].x} ${coords[0].y}`;\n\n    for (let i = 1; i < pointCount; i += 1) {\n      points += `L ${coords[i].x} ${coords[i].y}`;\n    }\n\n    path.setAttribute('fill', 'none');\n    path.setAttribute('stroke', color);\n    path.setAttribute('stroke-width', thickness);\n    path.setAttribute('d', points);\n\n    return path;\n  }\n\n  /**\n   * Return filled path with shadows of mountain peaks.\n   *\n   * @param {Object} svg\n   * @param {number} height\n   * @param {array} coords\n   * @param {number} valleyMinY\n   * @param {string} [color]\n   * @param {Object} [gradient]\n   * @returns {Object}\n   * @todo Remove SVG parameters as a dependency.\n   */\n  createShadowPath(svg, height, coords, valleyMinY, color = '#000000', gradient) {\n    const pointCount = coords.length;\n    const startXOffset = 20;\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n    let startX = false;\n    let endX;\n    let lowestY;\n    let points = '';\n\n    for (let i = 1; i < pointCount; i += 1) {\n      if (startX === false && coords[i].y > coords[i - 1].y) {\n        startX = coords[i - 1].x;\n        points += `M ${startX} ${coords[i - 1].y}`;\n        points += ` ${coords[i].x} ${coords[i].y}`;\n        lowestY = height - coords[i].y;\n      }\n\n      if (startX !== false && coords[i].y <= coords[i - 1].y) {\n        if (coords[i].y < lowestY) {\n          lowestY = height - coords[i].y;\n        }\n\n        endX = startX + startXOffset;\n        points += ` ${endX} ${height - Math.floor(Math.random() * (lowestY - valleyMinY))} Z`;\n        startX = false;\n      }\n\n      if (startX !== false) {\n        points += ` ${coords[i].x} ${coords[i].y}`;\n\n        if (coords[i].y > lowestY) {\n          lowestY = height - coords[i].y;\n        }\n\n        if (i === pointCount - 1) {\n          points += ` ${startX + startXOffset} ${height - Math.floor(Math.random() * (lowestY - valleyMinY))} Z`;\n          startX = false;\n        }\n      }\n    }\n\n    if (gradient) {\n      this.createGradient(svg, 'shadowGradient', gradient);\n      path.setAttribute('fill', 'url(#shadowGradient)');\n    } else {\n      path.setAttribute('fill', color);\n    }\n\n    path.setAttribute('d', points);\n\n    return path;\n  }\n\n}\n"]}