{"version":3,"sources":["SVGMountainRange.js","MergeObjects.js","MountainRangeCoordinates.js","RenderMountainRange.js"],"names":["SVGMountainRange","MergeObjects","_classCallCheck","this","_createClass","key","value","val","_typeof","Array","isArray","target","source","_this","isObject","Object","keys","forEach","assign","_defineProperty","mergeDeep","MountainRangeCoordinates","stage","initPeaks","peaks","valleys","flats","points","length","slice","definePeaks","count","minY","maxY","startWithPeak","subdividePeaks","detail","mapping","mapPointsToObject","coords","defineFlats","peakMinY","peakMaxY","Math","floor","random","valleyMinY","retryLimit","startY","retry","peakY","valleyY","insertDelta","defineValleyY","i","definePeakY","splice","point1","point2","passes","diff","abs","lowPoint","midpoint","spread","delta","arr","pass","subdivide","pointCount","xInc","width","point","push","x","y","height","pos","align","name","obj","stageWidth","index","desiredX","flatName","levelArea","RenderMountainRange","fill","shadow","ridge","svg","document","createElementNS","setAttribute","appendChild","createMountainPoly","color","gradient","createShadowPath","thickness","createRidgeline","svgNS","id","stops","grad","x1","y1","x2","y2","stop","offset","arguments","undefined","poly","map","coord","join","createGradient","namespaceURI","defs","querySelector","insertBefore","firstChild","path","startXOffset","startX","endX","lowestY","config","merge","defaultConfig","_merge$mergeDeep"],"mappings":"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","file":"svg-mountain-range.min.js","sourcesContent":["import MergeObjects from './MergeObjects';\nimport MountainRangeCoordinates from './MountainRangeCoordinates';\nimport RenderMountainRange from './RenderMountainRange';\n\n/**\n * Blah blah blah\n *\n * @class SVGMountainRange\n * @requires MergeObjects\n * @requires MountainRangeCoordinates\n * @requires RenderMountainRange\n */\nexport default class SVGMountainRange {\n\n  /**\n   * Create blah blah blah\n   *\n   * @param {Object} [config={ }] - Configuration settings for every apsect of generating the SVG mountain range.\n   * @returns {Object} Returns the results of the merge between the target and source objects.\n   *\n   * @memberOf SVGMountainRange\n   */\n  create(config = { }) {\n    const merge = new MergeObjects();\n    const defaultConfig = {\n      stage: {\n        width: 600,\n        height: 300\n      },\n      peaks: {\n        count: 1,\n        detail: 4,\n        minY: 200,\n        maxY: 300\n      },\n      valleys: {\n        minY: 50\n      }\n    };\n\n    const {\n      initPeaks,\n      stage,\n      peaks,\n      fill,\n      shadow,\n      ridge,\n      valleys,\n      flats\n    } = merge.mergeDeep(defaultConfig, config);\n\n    const coords = new MountainRangeCoordinates(stage, initPeaks, peaks, valleys, flats);\n    const svg = new RenderMountainRange(coords, stage, valleys, fill, shadow, ridge);\n\n    return svg;\n  }\n\n}\n","/**\n * @class MergeObjects\n */\n\n\nexport default class {\n  /**\n   * Utility method for determing if variable is an object.\n   *\n   * @memberOf MergeObjects\n   * @param {Object} val - The value to be tested if an object or not.\n   * @returns {boolean} Returns TRUE if the parameter is an object, otherwise FALSE.\n   */\n  isObject(val) {\n    return (val && typeof val === 'object' && !Array.isArray(val) && val !== null);\n  }\n\n  /**\n   * Perform a deep merge from source onto target.\n   *\n   * @memberOf MergeObjects\n   * @param {Object} target\n   * @param {Object} source\n   * @returns {Object} Returns the results of the merge between the target and source objects.\n   */\n  mergeDeep(target, source) {\n    if (this.isObject(target) && this.isObject(source)) {\n      Object.keys(source).forEach((key) => {\n        if (this.isObject(source[key])) {\n          if (!target[key]) Object.assign(target, { [key]: {} });\n          this.mergeDeep(target[key], source[key]);\n        } else {\n          Object.assign(target, { [key]: source[key] });\n        }\n      });\n    }\n\n    return target;\n  }\n}\n","/**\n * @class MountainRangeCoordinates\n */\n\nexport default class {\n\n /**\n   * Returns x/y coordinate objects in an array with procedurally generate points.\n   *\n   * @function constructor\n   * @memberOf MountainRangeCoordinates\n   * @param {Object} stage - The stage configuration object.\n   * @param {array} [initPeaks] - The initial defined peaks, instead of random.\n   * @param {Object} peaks - The peaks configuration object.\n   * @param {Object} valleys - The valleys configuration object.\n   * @param {array} [flats] - the flats configuration object.\n   * @returns {array} x/y coordinate objects in an array with procedurally generate points\n   */\n  constructor(stage, initPeaks, peaks, valleys, flats) {\n    let points = 0;\n\n    if (initPeaks && initPeaks.length) {\n      points = initPeaks.slice();\n    } else {\n      points = this.definePeaks(peaks.count, valleys.minY, peaks.minY, peaks.maxY, peaks.startWithPeak);\n    }\n\n    points = this.subdividePeaks(points, peaks.detail, valleys.minY, peaks.maxY);\n\n    const mapping = this.mapPointsToObject(stage, points);\n    let coords = 0;\n\n    if (flats) {\n      coords = this.defineFlats(mapping, flats);\n    } else {\n      coords = mapping;\n    }\n\n    return coords;\n  }\n\n  /**\n   * Returns a randomly generated y-axis point for a tall peak.\n   *\n   * @memberOf MountainRangeCoordinates\n   * @param {number} peakMinY - The minimum y-axis limit for the new point.\n   * @param {number} peakMaxY - The maximum y-axis limit for the new point.\n   * @returns {number} Randomly generated y-axis point for a tall peak.\n   */\n  definePeakY(peakMinY, peakMaxY) {\n    return Math.floor(Math.random() * (peakMaxY - peakMinY) + peakMinY);\n  }\n\n  /**\n   * Returns a randomly generated low valley y-axis value.\n   *\n   * @memberOf MountainRangeCoordinates\n   * @param {number} peakMinY - The minimum y-axis limit for a peak point.\n   * @param {number} valleyMinY - The minimum y-axis limit for a valley point.\n   * @returns {number} Randomly generated low valley y-axis value.\n   */\n  defineValleyY(peakMinY, valleyMinY) {\n    return Math.floor(Math.random() * (peakMinY - valleyMinY) + valleyMinY);\n  }\n\n  /**\n   * Returns an array of y-axis points.\n   *\n   * @memberOf MountainRangeCoordinates\n   * @param {number} count - The count of tallest mountain peaks.\n   * @param {number} valleyMinY - The lowest y-axis point.\n   * @param {number} peakMinY - The lowest y-axis point for the tallest peaks.\n   * @param {number} peakMaxY - The highest y-axis point for the tallest peaks.\n   * @param {boolean} [startWithPeak] - True if the left most point is a peak instead of a valley.\n   * @returns {array} Array of y-axis points that define the main geography of the mountain peaks.\n   */\n  definePeaks(count, valleyMinY, peakMinY, peakMaxY, startWithPeak) {\n    const retryLimit = 100;\n    const startY = startWithPeak ? peakMinY : valleyMinY;\n\n    let retry = 0;\n    let peakY = 0;\n    let valleyY = 0;\n    let points = 0;\n    let insertDelta = 1;\n\n    if (startWithPeak) {\n      points = [startY, this.defineValleyY(peakMinY, valleyMinY), startY];\n      insertDelta = 2;\n    } else {\n      points = [startY];\n    }\n\n    for (let i = 0; i < count * 2; i += 2) {\n      do {\n        peakY = this.definePeakY(peakMinY, peakMaxY);\n        retry += 1;\n      } while (retry < retryLimit && peakY > peakMaxY);\n\n      do {\n        valleyY = this.defineValleyY(peakMinY, valleyMinY);\n      } while (valleyY < valleyMinY);\n\n      points.splice(i + insertDelta, 0, peakY);\n      points.splice(i + insertDelta + 1, 0, valleyMinY);\n    }\n\n    return points;\n  }\n\n  /**\n   * Return random y-axis position based on two points.\n   *\n   * @memberOf MountainRangeCoordinates\n   * @param {number} point1 - First point to subdivide.\n   * @param {number} point2 - Second point to subdivide.\n   * @param {number} passes - The number of times to subdivide the points.\n   * @param {number} minY - The minimum y-axis limit for the new point.\n   * @param {number} maxY - The maximum y-axis limit for the new point.\n   * @returns Randomly offset Y-axis point.\n   */\n  subdivide(point1, point2, passes, minY, maxY) {\n    const retryLimit = 100;\n    const diff = Math.abs(point1 - point2);\n    const lowPoint = point1 < point2 ? point1 : point2;\n    const midpoint = Math.floor(diff / 2) + lowPoint;\n    const spread = Math.floor(midpoint / passes);\n\n    let retry = 0;\n    let delta = 0;\n\n    do {\n      delta = Math.floor(Math.random() * spread);\n      retry += 1;\n    } while (retry < retryLimit && (midpoint + delta > maxY || midpoint + delta < minY));\n\n    if (Math.floor(Math.random() * 2) === 1) {\n      delta *= -1;\n    }\n\n    return midpoint + delta;\n  }\n\n  /**\n   * Return array of random subdivided y-axis points.\n   *\n   * @memberOf MountainRangeCoordinates\n   * @param {array} points - An array of y-axis points.\n   * @param {number} passes - The number of times to subdivide the points.\n   * @param {number} minY - The minimum y-axis limit for the new point.\n   * @param {number} maxY - The maximum y-axis limit for the new point.\n   * @returns {array} Array of random subdivided y-axis points.\n   */\n  subdividePeaks(points, passes, minY, maxY) {\n    const arr = points.splice(0);\n\n    for (let pass = 0; pass < passes; pass += 1) {\n      for (let i = 0; i < arr.length - 1; i += 2) {\n        arr.splice(i + 1, 0, this.subdivide(arr[i], arr[i + 1], passes, minY, maxY));\n      }\n    }\n\n    return arr;\n  }\n\n  /**\n   * Return an array of X and Y coordinate objects.\n   *\n   * @memberOf MountainRangeCoordinates\n   * @param {Object} stage - The stage configuration object.\n   * @param {array} points - An array of y-axis points.\n   * @returns Array of X and Y coordinate objects.\n   */\n  mapPointsToObject(stage, points) {\n    const pointCount = points.length;\n    const xInc = stage.width / (pointCount - 1);\n    const coords = [];\n\n    for (let point = 0; point < pointCount; point += 1) {\n      coords.push({\n        x: xInc * point,\n        y: stage.height - points[point]\n      });\n    }\n\n    return coords;\n  }\n\n  /**\n   * Returns a coordinates array with leveled y-axis values for a specific width at given positions.\n   *\n   * @memberOf MountainRangeCoordinates\n   * @param {array} coords - The coordinates array.\n   * @param {number} pos - The x-axis position to start leveling.\n   * @param {number} width - The width of the area to be leveled.\n   * @param {string} align - The alignment of either left or right.\n   * @param {string} name - The name of the leveled area.\n   * @returns Coordinate object with a leveled y-axis value for a specific width at a given\n   * position.\n   */\n  levelArea(coords, pos, width, align, name) {\n    const obj = coords.slice();\n    const stageWidth = obj[obj.length - 1].x - obj[0].x;\n\n    let index = 0;\n    let desiredX = Math.floor(stageWidth * pos);\n\n    switch (align) {\n      case 'right':\n        desiredX -= width;\n        break;\n\n      case 'center':\n        desiredX -= Math.floor(width / 2);\n        break;\n\n      default:\n        break;\n    }\n\n    for (let i = 0; i < obj.length; i += 1) {\n      if (!index && obj[i].x > desiredX) {\n        index = i;\n        obj[i].flatName = name;\n      } else if (index && obj[i].x - obj[index].x <= width) {\n        obj[i].y = obj[index].y;\n      }\n    }\n\n    return obj;\n  }\n\n  /**\n   * Returns the coordinates array with flattened areas.\n   *\n   * @memberOf MountainRangeCoordinates\n   * @param {array} coords - The coordinates array.\n   * @param {array} flats - The flats configuration array.\n   * @returns {array} The coordinates array with flattened areas.\n   */\n  defineFlats(coords, flats) {\n    let obj = coords.slice();\n\n    for (let i = 0; i < flats.length; i += 1) {\n      obj = this.levelArea(obj, flats[i].pos, flats[i].width, flats[i].align, flats[i].name);\n    }\n\n    return obj;\n  }\n\n}\n","/**\n * yadda\n *\n * @class RenderMountainRange\n */\n\nexport default class {\n\n  /**\n   * Create SVG of mountain peaks.\n   *\n   * @function constructor\n   * @param {array} coords\n   * @param {Object} stage\n   * @param {Object} valleys\n   * @param {Object} fill\n   * @param {Object} shadow\n   * @param {Object} ridge\n   * @returns {Object}\n   *\n   * @memberOf RenderMountainRange\n   */\n  constructor(coords, stage, valleys, fill, shadow, ridge) {\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    svg.setAttribute('width', stage.width);\n    svg.setAttribute('height', stage.height);\n    svg.appendChild(\n      this.createMountainPoly(\n        svg,\n        coords,\n        stage.width,\n        stage.height,\n        (fill) ? fill.color : null,\n        (fill) ? fill.gradient : null\n      )\n    );\n\n    if (shadow) {\n      svg.appendChild(this.createShadowPath(svg, stage.height, coords, valleys.minY, shadow.color, shadow.gradient));\n    }\n\n    if (ridge && ridge.color && ridge.thickness) {\n      svg.appendChild(this.createRidgeline(coords, ridge.color, ridge.thickness));\n    }\n\n    return svg;\n  }\n\n  /**\n   * Returns gradient definition.\n   *\n   * @memberOf RenderMountainRange\n   * @param {Object} svg\n   * @param {string} id\n   * @param {Object} gradient\n   * @returns {Object}\n   */\n  createGradient(svgNS, id, gradient) {\n    const stops = gradient.stops;\n    const grad = document.createElementNS(svgNS, 'linearGradient');\n\n    grad.setAttribute('id', id);\n    grad.setAttribute('x1', gradient.x1);\n    grad.setAttribute('y1', gradient.y1);\n    grad.setAttribute('x2', gradient.x2);\n    grad.setAttribute('y2', gradient.y2);\n\n    for (let i = 0; i < stops.length; i += 1) {\n      const stop = document.createElementNS(svgNS, 'stop');\n\n      stop.setAttribute('offset', stops[i].offset);\n      stop.setAttribute('stop-color', stops[i]['stop-color']);\n\n      grad.appendChild(stop);\n    }\n\n    return grad;\n  }\n\n  /**\n   * Return SVG polygon element of mountain peaks.\n   *\n   * @memberOf RenderMountainRange\n   * @param {Object} svg -\n   * @param {array} coords -\n   * @param {number} width -\n   * @param {number} height -\n   * @param {string} [color] -\n   * @param {Object} [gradient] -\n   * @returns {Object} SVG polygon element of mountain peaks.\n   */\n  createMountainPoly(svg, coords, width, height, color = '#000000', gradient) {\n    const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n    const points = coords.map(coord => `${coord.x},${coord.y}`).join(' ');\n\n    poly.setAttribute('points', `${points} ${width},${height} 0,${height}`);\n\n    if (gradient) {\n      const grad = this.createGradient(svg.namespaceURI, 'mountainGradient', gradient);\n      const defs = svg.querySelector('defs') || svg.insertBefore(document.createElementNS(svg.namespaceURI, 'defs'), svg.firstChild);\n\n      defs.appendChild(grad);\n      poly.setAttribute('fill', 'url(#mountainGradient)');\n    } else {\n      poly.setAttribute('fill', color);\n    }\n\n    return poly;\n  }\n\n  /**\n   * Add a stroke to the mountain peak ridgeline.\n   *\n   * @memberOf RenderMountainRange\n   * @param {array} coords -\n   * @param {string} [color] -\n   * @param {number} [thickness] -\n   * @returns {Object}\n   */\n  createRidgeline(coords, color = '#000000', thickness = 1) {\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    const pointCount = coords.length;\n\n    let points = `M ${coords[0].x} ${coords[0].y}`;\n\n    for (let i = 1; i < pointCount; i += 1) {\n      points += `L ${coords[i].x} ${coords[i].y}`;\n    }\n\n    path.setAttribute('fill', 'none');\n    path.setAttribute('stroke', color);\n    path.setAttribute('stroke-width', thickness);\n    path.setAttribute('d', points);\n\n    return path;\n  }\n\n  /**\n   * Return filled path with shadows of mountain peaks.\n   *\n   * @memberOf RenderMountainRange\n   * @param {Object} svg\n   * @param {number} height\n   * @param {array} coords\n   * @param {number} valleyMinY\n   * @param {string} [color]\n   * @param {Object} [gradient]\n   * @returns {Object}\n   */\n  createShadowPath(svg, height, coords, valleyMinY, color = '#000000', gradient) {\n    const pointCount = coords.length;\n    const startXOffset = 20;\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n    let startX = false;\n    let endX;\n    let lowestY;\n    let points = '';\n\n    for (let i = 1; i < pointCount; i += 1) {\n      if (startX === false && coords[i].y > coords[i - 1].y) {\n        startX = coords[i - 1].x;\n        points += `M ${startX} ${coords[i - 1].y}`;\n        points += ` ${coords[i].x} ${coords[i].y}`;\n        lowestY = height - coords[i].y;\n      }\n\n      if (startX !== false && coords[i].y <= coords[i - 1].y) {\n        if (coords[i].y < lowestY) {\n          lowestY = height - coords[i].y;\n        }\n\n        endX = startX + startXOffset;\n        points += ` ${endX} ${height - Math.floor(Math.random() * (lowestY - valleyMinY))} Z`;\n        startX = false;\n      }\n\n      if (startX !== false) {\n        points += ` ${coords[i].x} ${coords[i].y}`;\n\n        if (coords[i].y > lowestY) {\n          lowestY = height - coords[i].y;\n        }\n\n        if (i === pointCount - 1) {\n          points += ` ${startX + startXOffset} ${height - Math.floor(Math.random() * (lowestY - valleyMinY))} Z`;\n          startX = false;\n        }\n      }\n    }\n\n    if (gradient) {\n      const grad = this.createGradient(svg.namespaceURI, 'shadowGradient', gradient);\n      const defs = svg.querySelector('defs') || svg.insertBefore(document.createElementNS(svg.namespaceURI, 'defs'), svg.firstChild);\n\n      defs.appendChild(grad);\n      path.setAttribute('fill', 'url(#shadowGradient)');\n    } else {\n      path.setAttribute('fill', color);\n    }\n\n    path.setAttribute('d', points);\n\n    return path;\n  }\n\n}\n"]}